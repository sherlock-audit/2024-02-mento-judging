Basic Velvet Lynx

medium

# MentoGovernor::propose Front-Running in Governance Proposal Creation

## Summary
A vulnerability in the proposal creation process allows attackers to front-run and cancel governance proposals, preventing their submission.

## Vulnerability Detail
The `propose` function in `GovernorUpgradeable.sol` generates a `proposalId` using proposal data. If an attacker submits and cancels a proposal with identical data before the original is processed, the original proposal is blocked due to duplicate `proposalId` checks.

When creating a new governance proposal, the `proposalId` is generated by hashing the proposal data `(_targets, _values, _calldatas, descriptionHash)`:

[GovernorUpgradeable.sol#L262](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/58fa0f81c4036f1a3b616fdffad2fd27e5d5ce21/contracts/governance/GovernorUpgradeable.sol#L251-L290)
```solidity
    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public virtual override returns (uint256) {
        require(
            getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),
            "Governor: proposer votes below proposal threshold"
        );

>>      uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));

        require(targets.length == values.length, "Governor: invalid proposal length");
        require(targets.length == calldatas.length, "Governor: invalid proposal length");
        require(targets.length > 0, "Governor: empty proposal");

        ProposalCore storage proposal = _proposals[proposalId];
        require(proposal.voteStart.isUnset(), "Governor: proposal already exists");

        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();
        uint64 deadline = snapshot + votingPeriod().toUint64();

        proposal.voteStart.setDeadline(snapshot);
        proposal.voteEnd.setDeadline(deadline);

        emit ProposalCreated(
            proposalId,
            _msgSender(),
            targets,
            values,
            new string[](targets.length),
            calldatas,
            snapshot,
            deadline,
            description
        );

        return proposalId;
    }
```

To prevent duplicated proposals, the current Governor implementation checks if the `proposalId` exists already. If it exists, the call will revert with the `Governor: proposal already exists` error message:

[GovernorUpgradeable.sol#L269](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/58fa0f81c4036f1a3b616fdffad2fd27e5d5ce21/contracts/governance/GovernorUpgradeable.sol#L269)
```solidity
        require(proposal.voteStart.isUnset(), "Governor: proposal already exists");
```

But an attacker can prevent users from creating governance proposals by front-running the creation proposal transaction with the same data, followed by an immediate call to the cancel function:

[GovernorCompatibilityBravoUpgradeable.sol#L113-L127](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/58fa0f81c4036f1a3b616fdffad2fd27e5d5ce21/contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol#L113-L127)
```solidity
    function cancel(uint256 proposalId) public virtual override {
        ProposalDetails storage details = _proposalDetails[proposalId];

        require(
            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),
            "GovernorBravo: proposer above threshold"
        );

        _cancel(
            details.targets,
            details.values,
            _encodeCalldata(details.signatures, details.calldatas),
            details.descriptionHash
        );
    }
```

[GovernorUpgradeable.sol#L372-L396](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/58fa0f81c4036f1a3b616fdffad2fd27e5d5ce21/contracts/governance/GovernorUpgradeable.sol#L372-L396)
```solidity
    /**
     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as
     * canceled to allow distinguishing it from executed proposals.
     *
     * Emits a {IGovernor-ProposalCanceled} event.
     */
    function _cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal virtual returns (uint256) {
        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);
        ProposalState status = state(proposalId);

        require(
            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,
            "Governor: proposal not active"
        );
        _proposals[proposalId].canceled = true;

        emit ProposalCanceled(proposalId);

        return proposalId;
    }
```


## Impact
This will prevent creating a proposal with the same proposal data. A proposal creator would have to change the proposal to try to create it again (however, it can be prevented again due to the aforementioned issue).

## Code Snippet
- [GovernorUpgradeable.sol#L262](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/58fa0f81c4036f1a3b616fdffad2fd27e5d5ce21/contracts/governance/GovernorUpgradeable.sol#L251-L290)
- [GovernorCompatibilityBravoUpgradeable.sol#L113-L127](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/58fa0f81c4036f1a3b616fdffad2fd27e5d5ce21/contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol#L113-L127)


## Tool used
Manual Review

## Recommendation
It may be tricky to mitigate, one solution could be to override the propose function and add `msg.sender` to the proposal hash when computing proposalId:

```diff
- uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));
+ uint256 proposalId = hashProposal(msg.sender, targets, values, calldatas, keccak256(bytes(description)));
```
